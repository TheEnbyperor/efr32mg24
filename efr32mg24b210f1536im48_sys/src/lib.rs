#![doc = "Peripheral access API for EFR32MG24B210F1536IM48 microcontrollers (generated using svd2rust v0.33.4 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.4/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn SMU_SECURE();
    fn SMU_S_PRIVILEGED();
    fn EMU();
    fn TIMER0();
    fn TIMER1();
    fn TIMER2();
    fn TIMER3();
    fn TIMER4();
    fn USART0_RX();
    fn USART0_TX();
    fn EUSART0_RX();
    fn EUSART0_TX();
    fn EUSART1_RX();
    fn EUSART1_TX();
    fn ICACHE0();
    fn BURTC();
    fn LETIMER0();
    fn SYSCFG();
    fn LDMA();
    fn LFXO();
    fn ULFRCO();
    fn GPIO_ODD();
    fn GPIO_EVEN();
    fn I2C0();
    fn I2C1();
    fn EMUDG();
    fn ACMP0();
    fn ACMP1();
    fn WDOG0();
    fn WDOG1();
    fn HFXO0();
    fn HFRCO0();
    fn HFRCOEM23();
    fn CMU();
    fn AES();
    fn IADC();
    fn MSC();
    fn DPLL0();
    fn PCNT0();
    fn SW0();
    fn SW1();
    fn SW2();
    fn SW3();
    fn SEMBRX();
    fn SEMBTX();
    fn KEYSCAN();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 70] = [
    Vector {
        _handler: SMU_SECURE,
    },
    Vector {
        _handler: SMU_S_PRIVILEGED,
    },
    Vector { _reserved: 0 },
    Vector { _handler: EMU },
    Vector { _handler: TIMER0 },
    Vector { _handler: TIMER1 },
    Vector { _handler: TIMER2 },
    Vector { _handler: TIMER3 },
    Vector { _handler: TIMER4 },
    Vector {
        _handler: USART0_RX,
    },
    Vector {
        _handler: USART0_TX,
    },
    Vector {
        _handler: EUSART0_RX,
    },
    Vector {
        _handler: EUSART0_TX,
    },
    Vector {
        _handler: EUSART1_RX,
    },
    Vector {
        _handler: EUSART1_TX,
    },
    Vector { _reserved: 0 },
    Vector { _handler: ICACHE0 },
    Vector { _handler: BURTC },
    Vector { _handler: LETIMER0 },
    Vector { _handler: SYSCFG },
    Vector { _reserved: 0 },
    Vector { _handler: LDMA },
    Vector { _handler: LFXO },
    Vector { _reserved: 0 },
    Vector { _handler: ULFRCO },
    Vector { _handler: GPIO_ODD },
    Vector {
        _handler: GPIO_EVEN,
    },
    Vector { _handler: I2C0 },
    Vector { _handler: I2C1 },
    Vector { _handler: EMUDG },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: ACMP0 },
    Vector { _handler: ACMP1 },
    Vector { _handler: WDOG0 },
    Vector { _handler: WDOG1 },
    Vector { _handler: HFXO0 },
    Vector { _handler: HFRCO0 },
    Vector {
        _handler: HFRCOEM23,
    },
    Vector { _handler: CMU },
    Vector { _handler: AES },
    Vector { _handler: IADC },
    Vector { _handler: MSC },
    Vector { _handler: DPLL0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: PCNT0 },
    Vector { _handler: SW0 },
    Vector { _handler: SW1 },
    Vector { _handler: SW2 },
    Vector { _handler: SW3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: SEMBRX },
    Vector { _handler: SEMBTX },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: KEYSCAN },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - SMU_SECURE"]
    SMU_SECURE = 0,
    #[doc = "1 - SMU_S_PRIVILEGED"]
    SMU_S_PRIVILEGED = 1,
    #[doc = "3 - EMU"]
    EMU = 3,
    #[doc = "4 - TIMER0"]
    TIMER0 = 4,
    #[doc = "5 - TIMER1"]
    TIMER1 = 5,
    #[doc = "6 - TIMER2"]
    TIMER2 = 6,
    #[doc = "7 - TIMER3"]
    TIMER3 = 7,
    #[doc = "8 - TIMER4"]
    TIMER4 = 8,
    #[doc = "9 - USART0_RX"]
    USART0_RX = 9,
    #[doc = "10 - USART0_TX"]
    USART0_TX = 10,
    #[doc = "11 - EUSART0_RX"]
    EUSART0_RX = 11,
    #[doc = "12 - EUSART0_TX"]
    EUSART0_TX = 12,
    #[doc = "13 - EUSART1_RX"]
    EUSART1_RX = 13,
    #[doc = "14 - EUSART1_TX"]
    EUSART1_TX = 14,
    #[doc = "16 - ICACHE0"]
    ICACHE0 = 16,
    #[doc = "17 - BURTC"]
    BURTC = 17,
    #[doc = "18 - LETIMER0"]
    LETIMER0 = 18,
    #[doc = "19 - SYSCFG"]
    SYSCFG = 19,
    #[doc = "21 - LDMA"]
    LDMA = 21,
    #[doc = "22 - LFXO"]
    LFXO = 22,
    #[doc = "24 - ULFRCO"]
    ULFRCO = 24,
    #[doc = "25 - GPIO_ODD"]
    GPIO_ODD = 25,
    #[doc = "26 - GPIO_EVEN"]
    GPIO_EVEN = 26,
    #[doc = "27 - I2C0"]
    I2C0 = 27,
    #[doc = "28 - I2C1"]
    I2C1 = 28,
    #[doc = "29 - EMUDG"]
    EMUDG = 29,
    #[doc = "40 - ACMP0"]
    ACMP0 = 40,
    #[doc = "41 - ACMP1"]
    ACMP1 = 41,
    #[doc = "42 - WDOG0"]
    WDOG0 = 42,
    #[doc = "43 - WDOG1"]
    WDOG1 = 43,
    #[doc = "44 - HFXO0"]
    HFXO0 = 44,
    #[doc = "45 - HFRCO0"]
    HFRCO0 = 45,
    #[doc = "46 - HFRCOEM23"]
    HFRCOEM23 = 46,
    #[doc = "47 - CMU"]
    CMU = 47,
    #[doc = "48 - AES"]
    AES = 48,
    #[doc = "49 - IADC"]
    IADC = 49,
    #[doc = "50 - MSC"]
    MSC = 50,
    #[doc = "51 - DPLL0"]
    DPLL0 = 51,
    #[doc = "54 - PCNT0"]
    PCNT0 = 54,
    #[doc = "55 - SW0"]
    SW0 = 55,
    #[doc = "56 - SW1"]
    SW1 = 56,
    #[doc = "57 - SW2"]
    SW2 = 57,
    #[doc = "58 - SW3"]
    SW3 = 58,
    #[doc = "65 - SEMBRX"]
    SEMBRX = 65,
    #[doc = "66 - SEMBTX"]
    SEMBTX = 66,
    #[doc = "69 - KEYSCAN"]
    KEYSCAN = 69,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "ACMP0_NS Registers"]
pub struct Acmp0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Acmp0Ns {}
impl Acmp0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const acmp0_ns::RegisterBlock = 0x5900_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const acmp0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Acmp0Ns {
    type Target = acmp0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Acmp0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Acmp0Ns").finish()
    }
}
#[doc = "ACMP0_NS Registers"]
pub mod acmp0_ns;
#[doc = "ACMP0_S Registers"]
pub struct Acmp0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Acmp0S {}
impl Acmp0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const acmp0_s::RegisterBlock = 0x4900_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const acmp0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Acmp0S {
    type Target = acmp0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Acmp0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Acmp0S").finish()
    }
}
#[doc = "ACMP0_S Registers"]
pub mod acmp0_s;
#[doc = "ACMP1_NS Registers"]
pub struct Acmp1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Acmp1Ns {}
impl Acmp1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const acmp1_ns::RegisterBlock = 0x5900_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const acmp1_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Acmp1Ns {
    type Target = acmp1_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Acmp1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Acmp1Ns").finish()
    }
}
#[doc = "ACMP1_NS Registers"]
pub mod acmp1_ns;
#[doc = "ACMP1_S Registers"]
pub struct Acmp1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Acmp1S {}
impl Acmp1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const acmp1_s::RegisterBlock = 0x4900_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const acmp1_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Acmp1S {
    type Target = acmp1_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Acmp1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Acmp1S").finish()
    }
}
#[doc = "ACMP1_S Registers"]
pub mod acmp1_s;
#[doc = "BURAM_NS Registers"]
pub struct BuramNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BuramNs {}
impl BuramNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const buram_ns::RegisterBlock = 0x5008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const buram_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BuramNs {
    type Target = buram_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BuramNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BuramNs").finish()
    }
}
#[doc = "BURAM_NS Registers"]
pub mod buram_ns;
#[doc = "BURAM_S Registers"]
pub struct BuramS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BuramS {}
impl BuramS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const buram_s::RegisterBlock = 0x4008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const buram_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BuramS {
    type Target = buram_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BuramS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BuramS").finish()
    }
}
#[doc = "BURAM_S Registers"]
pub mod buram_s;
#[doc = "BURTC_NS Registers"]
pub struct BurtcNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BurtcNs {}
impl BurtcNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const burtc_ns::RegisterBlock = 0x5006_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const burtc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BurtcNs {
    type Target = burtc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BurtcNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BurtcNs").finish()
    }
}
#[doc = "BURTC_NS Registers"]
pub mod burtc_ns;
#[doc = "BURTC_S Registers"]
pub struct BurtcS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BurtcS {}
impl BurtcS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const burtc_s::RegisterBlock = 0x4006_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const burtc_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BurtcS {
    type Target = burtc_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BurtcS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BurtcS").finish()
    }
}
#[doc = "BURTC_S Registers"]
pub mod burtc_s;
#[doc = "CMU_NS Registers"]
pub struct CmuNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CmuNs {}
impl CmuNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cmu_ns::RegisterBlock = 0x5000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cmu_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CmuNs {
    type Target = cmu_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CmuNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CmuNs").finish()
    }
}
#[doc = "CMU_NS Registers"]
pub mod cmu_ns;
#[doc = "CMU_S Registers"]
pub struct CmuS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CmuS {}
impl CmuS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cmu_s::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cmu_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CmuS {
    type Target = cmu_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CmuS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CmuS").finish()
    }
}
#[doc = "CMU_S Registers"]
pub mod cmu_s;
#[doc = "DCDC_NS Registers"]
pub struct DcdcNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DcdcNs {}
impl DcdcNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dcdc_ns::RegisterBlock = 0x5009_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dcdc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DcdcNs {
    type Target = dcdc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DcdcNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DcdcNs").finish()
    }
}
#[doc = "DCDC_NS Registers"]
pub mod dcdc_ns;
#[doc = "DCDC_S Registers"]
pub struct DcdcS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DcdcS {}
impl DcdcS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dcdc_s::RegisterBlock = 0x4009_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dcdc_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DcdcS {
    type Target = dcdc_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DcdcS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DcdcS").finish()
    }
}
#[doc = "DCDC_S Registers"]
pub mod dcdc_s;
#[doc = "DMEM_NS Registers"]
pub struct DmemNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DmemNs {}
impl DmemNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmem_ns::RegisterBlock = 0x500b_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmem_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DmemNs {
    type Target = dmem_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DmemNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DmemNs").finish()
    }
}
#[doc = "DMEM_NS Registers"]
pub mod dmem_ns;
#[doc = "DMEM_S Registers"]
pub struct DmemS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DmemS {}
impl DmemS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmem_s::RegisterBlock = 0x400b_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmem_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DmemS {
    type Target = dmem_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DmemS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DmemS").finish()
    }
}
#[doc = "DMEM_S Registers"]
pub mod dmem_s;
#[doc = "DPLL0_NS Registers"]
pub struct Dpll0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dpll0Ns {}
impl Dpll0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dpll0_ns::RegisterBlock = 0x5001_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dpll0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dpll0Ns {
    type Target = dpll0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dpll0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dpll0Ns").finish()
    }
}
#[doc = "DPLL0_NS Registers"]
pub mod dpll0_ns;
#[doc = "DPLL0_S Registers"]
pub struct Dpll0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dpll0S {}
impl Dpll0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dpll0_s::RegisterBlock = 0x4001_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dpll0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dpll0S {
    type Target = dpll0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dpll0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dpll0S").finish()
    }
}
#[doc = "DPLL0_S Registers"]
pub mod dpll0_s;
#[doc = "EMU_NS Registers"]
pub struct EmuNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EmuNs {}
impl EmuNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const emu_ns::RegisterBlock = 0x5000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const emu_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EmuNs {
    type Target = emu_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EmuNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EmuNs").finish()
    }
}
#[doc = "EMU_NS Registers"]
pub mod emu_ns;
#[doc = "EMU_S Registers"]
pub struct EmuS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EmuS {}
impl EmuS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const emu_s::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const emu_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EmuS {
    type Target = emu_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EmuS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EmuS").finish()
    }
}
#[doc = "EMU_S Registers"]
pub mod emu_s;
#[doc = "EUSART0_NS Registers"]
pub struct Eusart0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eusart0Ns {}
impl Eusart0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusart0_ns::RegisterBlock = 0x5b01_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusart0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Eusart0Ns {
    type Target = eusart0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eusart0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eusart0Ns").finish()
    }
}
#[doc = "EUSART0_NS Registers"]
pub mod eusart0_ns;
#[doc = "EUSART0_S Registers"]
pub struct Eusart0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eusart0S {}
impl Eusart0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusart0_s::RegisterBlock = 0x4b01_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusart0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Eusart0S {
    type Target = eusart0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eusart0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eusart0S").finish()
    }
}
#[doc = "EUSART0_S Registers"]
pub mod eusart0_s;
#[doc = "EUSART1_NS Registers"]
pub struct Eusart1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eusart1Ns {}
impl Eusart1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusart1_ns::RegisterBlock = 0x500a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusart1_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Eusart1Ns {
    type Target = eusart1_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eusart1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eusart1Ns").finish()
    }
}
#[doc = "EUSART1_NS Registers"]
pub mod eusart1_ns;
#[doc = "EUSART1_S Registers"]
pub struct Eusart1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eusart1S {}
impl Eusart1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eusart1_s::RegisterBlock = 0x400a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eusart1_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Eusart1S {
    type Target = eusart1_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eusart1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eusart1S").finish()
    }
}
#[doc = "EUSART1_S Registers"]
pub mod eusart1_s;
#[doc = "FSRCO_NS Registers"]
pub struct FsrcoNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FsrcoNs {}
impl FsrcoNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsrco_ns::RegisterBlock = 0x5001_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsrco_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for FsrcoNs {
    type Target = fsrco_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FsrcoNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FsrcoNs").finish()
    }
}
#[doc = "FSRCO_NS Registers"]
pub mod fsrco_ns;
#[doc = "FSRCO_S Registers"]
pub struct FsrcoS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FsrcoS {}
impl FsrcoS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsrco_s::RegisterBlock = 0x4001_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsrco_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for FsrcoS {
    type Target = fsrco_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FsrcoS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FsrcoS").finish()
    }
}
#[doc = "FSRCO_S Registers"]
pub mod fsrco_s;
#[doc = "GPCRC_NS Registers"]
pub struct GpcrcNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GpcrcNs {}
impl GpcrcNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpcrc_ns::RegisterBlock = 0x5008_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpcrc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GpcrcNs {
    type Target = gpcrc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GpcrcNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GpcrcNs").finish()
    }
}
#[doc = "GPCRC_NS Registers"]
pub mod gpcrc_ns;
#[doc = "GPCRC_S Registers"]
pub struct GpcrcS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GpcrcS {}
impl GpcrcS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpcrc_s::RegisterBlock = 0x4008_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpcrc_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GpcrcS {
    type Target = gpcrc_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GpcrcS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GpcrcS").finish()
    }
}
#[doc = "GPCRC_S Registers"]
pub mod gpcrc_s;
#[doc = "GPIO_NS Registers"]
pub struct GpioNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GpioNs {}
impl GpioNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio_ns::RegisterBlock = 0x5003_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GpioNs {
    type Target = gpio_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GpioNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GpioNs").finish()
    }
}
#[doc = "GPIO_NS Registers"]
pub mod gpio_ns;
#[doc = "GPIO_S Registers"]
pub struct GpioS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GpioS {}
impl GpioS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio_s::RegisterBlock = 0x4003_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GpioS {
    type Target = gpio_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GpioS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GpioS").finish()
    }
}
#[doc = "GPIO_S Registers"]
pub mod gpio_s;
#[doc = "HFRCO0_NS Registers"]
pub struct Hfrco0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Hfrco0Ns {}
impl Hfrco0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hfrco0_ns::RegisterBlock = 0x5001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hfrco0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Hfrco0Ns {
    type Target = hfrco0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Hfrco0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hfrco0Ns").finish()
    }
}
#[doc = "HFRCO0_NS Registers"]
pub mod hfrco0_ns;
#[doc = "HFRCO0_S Registers"]
pub struct Hfrco0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Hfrco0S {}
impl Hfrco0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hfrco0_s::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hfrco0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Hfrco0S {
    type Target = hfrco0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Hfrco0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hfrco0S").finish()
    }
}
#[doc = "HFRCO0_S Registers"]
pub mod hfrco0_s;
#[doc = "HFRCOEM23_NS Registers"]
pub struct Hfrcoem23Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Hfrcoem23Ns {}
impl Hfrcoem23Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hfrcoem23_ns::RegisterBlock = 0x5a00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hfrcoem23_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Hfrcoem23Ns {
    type Target = hfrcoem23_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Hfrcoem23Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hfrcoem23Ns").finish()
    }
}
#[doc = "HFRCOEM23_NS Registers"]
pub mod hfrcoem23_ns;
#[doc = "HFRCOEM23_S Registers"]
pub struct Hfrcoem23S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Hfrcoem23S {}
impl Hfrcoem23S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hfrcoem23_s::RegisterBlock = 0x4a00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hfrcoem23_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Hfrcoem23S {
    type Target = hfrcoem23_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Hfrcoem23S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hfrcoem23S").finish()
    }
}
#[doc = "HFRCOEM23_S Registers"]
pub mod hfrcoem23_s;
#[doc = "HFXO0_NS Registers"]
pub struct Hfxo0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Hfxo0Ns {}
impl Hfxo0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hfxo0_ns::RegisterBlock = 0x5a00_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hfxo0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Hfxo0Ns {
    type Target = hfxo0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Hfxo0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hfxo0Ns").finish()
    }
}
#[doc = "HFXO0_NS Registers"]
pub mod hfxo0_ns;
#[doc = "HFXO0_S Registers"]
pub struct Hfxo0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Hfxo0S {}
impl Hfxo0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hfxo0_s::RegisterBlock = 0x4a00_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hfxo0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Hfxo0S {
    type Target = hfxo0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Hfxo0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hfxo0S").finish()
    }
}
#[doc = "HFXO0_S Registers"]
pub mod hfxo0_s;
#[doc = "HOSTMAILBOX_NS Registers"]
pub struct HostmailboxNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HostmailboxNs {}
impl HostmailboxNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hostmailbox_ns::RegisterBlock = 0x5009_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hostmailbox_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HostmailboxNs {
    type Target = hostmailbox_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HostmailboxNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HostmailboxNs").finish()
    }
}
#[doc = "HOSTMAILBOX_NS Registers"]
pub mod hostmailbox_ns;
#[doc = "HOSTMAILBOX_S Registers"]
pub struct HostmailboxS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HostmailboxS {}
impl HostmailboxS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hostmailbox_s::RegisterBlock = 0x4009_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hostmailbox_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HostmailboxS {
    type Target = hostmailbox_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HostmailboxS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HostmailboxS").finish()
    }
}
#[doc = "HOSTMAILBOX_S Registers"]
pub mod hostmailbox_s;
#[doc = "I2C0_NS Registers"]
pub struct I2c0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c0Ns {}
impl I2c0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0_ns::RegisterBlock = 0x5b00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c0Ns {
    type Target = i2c0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c0Ns").finish()
    }
}
#[doc = "I2C0_NS Registers"]
pub mod i2c0_ns;
#[doc = "I2C0_S Registers"]
pub struct I2c0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c0S {}
impl I2c0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0_s::RegisterBlock = 0x4b00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c0S {
    type Target = i2c0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c0S").finish()
    }
}
#[doc = "I2C0_S Registers"]
pub mod i2c0_s;
#[doc = "I2C1_NS Registers"]
pub struct I2c1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c1Ns {}
impl I2c1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c1_ns::RegisterBlock = 0x5006_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c1_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c1Ns {
    type Target = i2c1_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c1Ns").finish()
    }
}
#[doc = "I2C1_NS Registers"]
pub mod i2c1_ns;
#[doc = "I2C1_S Registers"]
pub struct I2c1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c1S {}
impl I2c1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c1_s::RegisterBlock = 0x4006_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c1_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c1S {
    type Target = i2c1_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c1S").finish()
    }
}
#[doc = "I2C1_S Registers"]
pub mod i2c1_s;
#[doc = "IADC0_NS Registers"]
pub struct Iadc0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iadc0Ns {}
impl Iadc0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iadc0_ns::RegisterBlock = 0x5900_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iadc0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iadc0Ns {
    type Target = iadc0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iadc0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iadc0Ns").finish()
    }
}
#[doc = "IADC0_NS Registers"]
pub mod iadc0_ns;
#[doc = "IADC0_S Registers"]
pub struct Iadc0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iadc0S {}
impl Iadc0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iadc0_s::RegisterBlock = 0x4900_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iadc0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iadc0S {
    type Target = iadc0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iadc0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iadc0S").finish()
    }
}
#[doc = "IADC0_S Registers"]
pub mod iadc0_s;
#[doc = "ICACHE0_NS Registers"]
pub struct Icache0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Icache0Ns {}
impl Icache0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const icache0_ns::RegisterBlock = 0x5003_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const icache0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Icache0Ns {
    type Target = icache0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Icache0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Icache0Ns").finish()
    }
}
#[doc = "ICACHE0_NS Registers"]
pub mod icache0_ns;
#[doc = "ICACHE0_S Registers"]
pub struct Icache0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Icache0S {}
impl Icache0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const icache0_s::RegisterBlock = 0x4003_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const icache0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Icache0S {
    type Target = icache0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Icache0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Icache0S").finish()
    }
}
#[doc = "ICACHE0_S Registers"]
pub mod icache0_s;
#[doc = "KEYSCAN_NS Registers"]
pub struct KeyscanNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for KeyscanNs {}
impl KeyscanNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const keyscan_ns::RegisterBlock = 0x500b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const keyscan_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for KeyscanNs {
    type Target = keyscan_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for KeyscanNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("KeyscanNs").finish()
    }
}
#[doc = "KEYSCAN_NS Registers"]
pub mod keyscan_ns;
#[doc = "KEYSCAN_S Registers"]
pub struct KeyscanS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for KeyscanS {}
impl KeyscanS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const keyscan_s::RegisterBlock = 0x400b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const keyscan_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for KeyscanS {
    type Target = keyscan_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for KeyscanS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("KeyscanS").finish()
    }
}
#[doc = "KEYSCAN_S Registers"]
pub mod keyscan_s;
#[doc = "LDMAXBAR_NS Registers"]
pub struct LdmaxbarNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LdmaxbarNs {}
impl LdmaxbarNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ldmaxbar_ns::RegisterBlock = 0x5004_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ldmaxbar_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LdmaxbarNs {
    type Target = ldmaxbar_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LdmaxbarNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LdmaxbarNs").finish()
    }
}
#[doc = "LDMAXBAR_NS Registers"]
pub mod ldmaxbar_ns;
#[doc = "LDMAXBAR_S Registers"]
pub struct LdmaxbarS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LdmaxbarS {}
impl LdmaxbarS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ldmaxbar_s::RegisterBlock = 0x4004_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ldmaxbar_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LdmaxbarS {
    type Target = ldmaxbar_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LdmaxbarS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LdmaxbarS").finish()
    }
}
#[doc = "LDMAXBAR_S Registers"]
pub mod ldmaxbar_s;
#[doc = "LDMA_NS Registers"]
pub struct LdmaNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LdmaNs {}
impl LdmaNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ldma_ns::RegisterBlock = 0x5004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ldma_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LdmaNs {
    type Target = ldma_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LdmaNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LdmaNs").finish()
    }
}
#[doc = "LDMA_NS Registers"]
pub mod ldma_ns;
#[doc = "LDMA_S Registers"]
pub struct LdmaS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LdmaS {}
impl LdmaS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ldma_s::RegisterBlock = 0x4004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ldma_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LdmaS {
    type Target = ldma_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LdmaS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LdmaS").finish()
    }
}
#[doc = "LDMA_S Registers"]
pub mod ldma_s;
#[doc = "LETIMER0_NS Registers"]
pub struct Letimer0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Letimer0Ns {}
impl Letimer0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const letimer0_ns::RegisterBlock = 0x5900_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const letimer0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Letimer0Ns {
    type Target = letimer0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Letimer0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Letimer0Ns").finish()
    }
}
#[doc = "LETIMER0_NS Registers"]
pub mod letimer0_ns;
#[doc = "LETIMER0_S Registers"]
pub struct Letimer0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Letimer0S {}
impl Letimer0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const letimer0_s::RegisterBlock = 0x4900_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const letimer0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Letimer0S {
    type Target = letimer0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Letimer0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Letimer0S").finish()
    }
}
#[doc = "LETIMER0_S Registers"]
pub mod letimer0_s;
#[doc = "LFRCO_NS Registers"]
pub struct LfrcoNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LfrcoNs {}
impl LfrcoNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lfrco_ns::RegisterBlock = 0x5002_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lfrco_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LfrcoNs {
    type Target = lfrco_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LfrcoNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LfrcoNs").finish()
    }
}
#[doc = "LFRCO_NS Registers"]
pub mod lfrco_ns;
#[doc = "LFRCO_S Registers"]
pub struct LfrcoS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LfrcoS {}
impl LfrcoS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lfrco_s::RegisterBlock = 0x4002_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lfrco_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LfrcoS {
    type Target = lfrco_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LfrcoS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LfrcoS").finish()
    }
}
#[doc = "LFRCO_S Registers"]
pub mod lfrco_s;
#[doc = "LFXO_NS Registers"]
pub struct LfxoNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LfxoNs {}
impl LfxoNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lfxo_ns::RegisterBlock = 0x5002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lfxo_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LfxoNs {
    type Target = lfxo_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LfxoNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LfxoNs").finish()
    }
}
#[doc = "LFXO_NS Registers"]
pub mod lfxo_ns;
#[doc = "LFXO_S Registers"]
pub struct LfxoS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LfxoS {}
impl LfxoS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lfxo_s::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lfxo_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LfxoS {
    type Target = lfxo_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LfxoS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LfxoS").finish()
    }
}
#[doc = "LFXO_S Registers"]
pub mod lfxo_s;
#[doc = "MSC_NS Registers"]
pub struct MscNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MscNs {}
impl MscNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msc_ns::RegisterBlock = 0x5003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MscNs {
    type Target = msc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MscNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MscNs").finish()
    }
}
#[doc = "MSC_NS Registers"]
pub mod msc_ns;
#[doc = "MSC_S Registers"]
pub struct MscS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MscS {}
impl MscS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msc_s::RegisterBlock = 0x4003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msc_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MscS {
    type Target = msc_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MscS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MscS").finish()
    }
}
#[doc = "MSC_S Registers"]
pub mod msc_s;
#[doc = "MVP_NS Registers"]
pub struct MvpNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MvpNs {}
impl MvpNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mvp_ns::RegisterBlock = 0x5d00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mvp_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MvpNs {
    type Target = mvp_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MvpNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MvpNs").finish()
    }
}
#[doc = "MVP_NS Registers"]
pub mod mvp_ns;
#[doc = "MVP_S Registers"]
pub struct MvpS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MvpS {}
impl MvpS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mvp_s::RegisterBlock = 0x4d00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mvp_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MvpS {
    type Target = mvp_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MvpS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MvpS").finish()
    }
}
#[doc = "MVP_S Registers"]
pub mod mvp_s;
#[doc = "PCNT0_NS Registers"]
pub struct Pcnt0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pcnt0Ns {}
impl Pcnt0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pcnt0_ns::RegisterBlock = 0x5903_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pcnt0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pcnt0Ns {
    type Target = pcnt0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pcnt0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pcnt0Ns").finish()
    }
}
#[doc = "PCNT0_NS Registers"]
pub mod pcnt0_ns;
#[doc = "PCNT0_S Registers"]
pub struct Pcnt0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pcnt0S {}
impl Pcnt0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pcnt0_s::RegisterBlock = 0x4903_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pcnt0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pcnt0S {
    type Target = pcnt0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pcnt0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pcnt0S").finish()
    }
}
#[doc = "PCNT0_S Registers"]
pub mod pcnt0_s;
#[doc = "PRS_NS Registers"]
pub struct PrsNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PrsNs {}
impl PrsNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const prs_ns::RegisterBlock = 0x5003_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const prs_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PrsNs {
    type Target = prs_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PrsNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PrsNs").finish()
    }
}
#[doc = "PRS_NS Registers"]
pub mod prs_ns;
#[doc = "PRS_S Registers"]
pub struct PrsS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PrsS {}
impl PrsS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const prs_s::RegisterBlock = 0x4003_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const prs_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PrsS {
    type Target = prs_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PrsS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PrsS").finish()
    }
}
#[doc = "PRS_S Registers"]
pub mod prs_s;
#[doc = "RADIOAES_NS Registers"]
pub struct RadioaesNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RadioaesNs {}
impl RadioaesNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const radioaes_ns::RegisterBlock = 0x5400_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const radioaes_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RadioaesNs {
    type Target = radioaes_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RadioaesNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RadioaesNs").finish()
    }
}
#[doc = "RADIOAES_NS Registers"]
pub mod radioaes_ns;
#[doc = "RADIOAES_S Registers"]
pub struct RadioaesS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RadioaesS {}
impl RadioaesS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const radioaes_s::RegisterBlock = 0x4400_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const radioaes_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RadioaesS {
    type Target = radioaes_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RadioaesS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RadioaesS").finish()
    }
}
#[doc = "RADIOAES_S Registers"]
pub mod radioaes_s;
#[doc = "SCRATCHPAD_NS Registers"]
pub struct ScratchpadNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScratchpadNs {}
impl ScratchpadNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scratchpad_ns::RegisterBlock = 0x5000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scratchpad_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ScratchpadNs {
    type Target = scratchpad_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScratchpadNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScratchpadNs").finish()
    }
}
#[doc = "SCRATCHPAD_NS Registers"]
pub mod scratchpad_ns;
#[doc = "SCRATCHPAD_S Registers"]
pub struct ScratchpadS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ScratchpadS {}
impl ScratchpadS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scratchpad_s::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scratchpad_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ScratchpadS {
    type Target = scratchpad_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ScratchpadS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScratchpadS").finish()
    }
}
#[doc = "SCRATCHPAD_S Registers"]
pub mod scratchpad_s;
#[doc = "SEMAILBOX_NS_HOST Registers"]
pub struct SemailboxNsHost {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SemailboxNsHost {}
impl SemailboxNsHost {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const semailbox_ns_host::RegisterBlock = 0x5c00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const semailbox_ns_host::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SemailboxNsHost {
    type Target = semailbox_ns_host::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SemailboxNsHost {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SemailboxNsHost").finish()
    }
}
#[doc = "SEMAILBOX_NS_HOST Registers"]
pub mod semailbox_ns_host;
#[doc = "SEMAILBOX_S_HOST Registers"]
pub struct SemailboxSHost {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SemailboxSHost {}
impl SemailboxSHost {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const semailbox_s_host::RegisterBlock = 0x4c00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const semailbox_s_host::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SemailboxSHost {
    type Target = semailbox_s_host::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SemailboxSHost {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SemailboxSHost").finish()
    }
}
#[doc = "SEMAILBOX_S_HOST Registers"]
pub mod semailbox_s_host;
#[doc = "SMU_NS Registers"]
pub struct SmuNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SmuNs {}
impl SmuNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smu_ns::RegisterBlock = 0x5400_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smu_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SmuNs {
    type Target = smu_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SmuNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SmuNs").finish()
    }
}
#[doc = "SMU_NS Registers"]
pub mod smu_ns;
#[doc = "SMU_NS_CFGNS Registers"]
pub struct SmuNsCfgns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SmuNsCfgns {}
impl SmuNsCfgns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smu_ns_cfgns::RegisterBlock = 0x5400_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smu_ns_cfgns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SmuNsCfgns {
    type Target = smu_ns_cfgns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SmuNsCfgns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SmuNsCfgns").finish()
    }
}
#[doc = "SMU_NS_CFGNS Registers"]
pub mod smu_ns_cfgns;
#[doc = "SMU_S Registers"]
pub struct SmuS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SmuS {}
impl SmuS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smu_s::RegisterBlock = 0x4400_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smu_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SmuS {
    type Target = smu_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SmuS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SmuS").finish()
    }
}
#[doc = "SMU_S Registers"]
pub mod smu_s;
#[doc = "SMU_S_CFGNS Registers"]
pub struct SmuSCfgns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SmuSCfgns {}
impl SmuSCfgns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smu_s_cfgns::RegisterBlock = 0x4400_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smu_s_cfgns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SmuSCfgns {
    type Target = smu_s_cfgns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SmuSCfgns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SmuSCfgns").finish()
    }
}
#[doc = "SMU_S_CFGNS Registers"]
pub mod smu_s_cfgns;
#[doc = "SYSCFG_NS Registers"]
pub struct SyscfgNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SyscfgNs {}
impl SyscfgNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const syscfg_ns::RegisterBlock = 0x5007_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const syscfg_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SyscfgNs {
    type Target = syscfg_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SyscfgNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SyscfgNs").finish()
    }
}
#[doc = "SYSCFG_NS Registers"]
pub mod syscfg_ns;
#[doc = "SYSCFG_NS_CFGNS Registers"]
pub struct SyscfgNsCfgns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SyscfgNsCfgns {}
impl SyscfgNsCfgns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const syscfg_ns_cfgns::RegisterBlock = 0x5007_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const syscfg_ns_cfgns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SyscfgNsCfgns {
    type Target = syscfg_ns_cfgns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SyscfgNsCfgns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SyscfgNsCfgns").finish()
    }
}
#[doc = "SYSCFG_NS_CFGNS Registers"]
pub mod syscfg_ns_cfgns;
#[doc = "SYSCFG_S Registers"]
pub struct SyscfgS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SyscfgS {}
impl SyscfgS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const syscfg_s::RegisterBlock = 0x4007_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const syscfg_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SyscfgS {
    type Target = syscfg_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SyscfgS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SyscfgS").finish()
    }
}
#[doc = "SYSCFG_S Registers"]
pub mod syscfg_s;
#[doc = "SYSCFG_S_CFGNS Registers"]
pub struct SyscfgSCfgns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SyscfgSCfgns {}
impl SyscfgSCfgns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const syscfg_s_cfgns::RegisterBlock = 0x4007_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const syscfg_s_cfgns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SyscfgSCfgns {
    type Target = syscfg_s_cfgns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SyscfgSCfgns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SyscfgSCfgns").finish()
    }
}
#[doc = "SYSCFG_S_CFGNS Registers"]
pub mod syscfg_s_cfgns;
#[doc = "SYSRTC0_NS Registers"]
pub struct Sysrtc0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sysrtc0Ns {}
impl Sysrtc0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sysrtc0_ns::RegisterBlock = 0x500a_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sysrtc0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sysrtc0Ns {
    type Target = sysrtc0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sysrtc0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sysrtc0Ns").finish()
    }
}
#[doc = "SYSRTC0_NS Registers"]
pub mod sysrtc0_ns;
#[doc = "SYSRTC0_S Registers"]
pub struct Sysrtc0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sysrtc0S {}
impl Sysrtc0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sysrtc0_s::RegisterBlock = 0x400a_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sysrtc0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sysrtc0S {
    type Target = sysrtc0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sysrtc0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sysrtc0S").finish()
    }
}
#[doc = "SYSRTC0_S Registers"]
pub mod sysrtc0_s;
#[doc = "TIMER0_NS Registers"]
pub struct Timer0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer0Ns {}
impl Timer0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0_ns::RegisterBlock = 0x5004_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer0Ns {
    type Target = timer0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0Ns").finish()
    }
}
#[doc = "TIMER0_NS Registers"]
pub mod timer0_ns;
#[doc = "TIMER0_S Registers"]
pub struct Timer0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer0S {}
impl Timer0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0_s::RegisterBlock = 0x4004_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer0S {
    type Target = timer0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0S").finish()
    }
}
#[doc = "TIMER0_S Registers"]
pub mod timer0_s;
#[doc = "TIMER1_NS Registers"]
pub struct Timer1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer1Ns {}
impl Timer1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer1_ns::RegisterBlock = 0x5004_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer1_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer1Ns {
    type Target = timer1_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer1Ns").finish()
    }
}
#[doc = "TIMER1_NS Registers"]
pub mod timer1_ns;
#[doc = "TIMER1_S Registers"]
pub struct Timer1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer1S {}
impl Timer1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer1_s::RegisterBlock = 0x4004_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer1_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer1S {
    type Target = timer1_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer1S").finish()
    }
}
#[doc = "TIMER1_S Registers"]
pub mod timer1_s;
#[doc = "TIMER2_NS Registers"]
pub struct Timer2Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer2Ns {}
impl Timer2Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer2_ns::RegisterBlock = 0x5005_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer2_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer2Ns {
    type Target = timer2_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer2Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer2Ns").finish()
    }
}
#[doc = "TIMER2_NS Registers"]
pub mod timer2_ns;
#[doc = "TIMER2_S Registers"]
pub struct Timer2S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer2S {}
impl Timer2S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer2_s::RegisterBlock = 0x4005_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer2_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer2S {
    type Target = timer2_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer2S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer2S").finish()
    }
}
#[doc = "TIMER2_S Registers"]
pub mod timer2_s;
#[doc = "TIMER3_NS Registers"]
pub struct Timer3Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer3Ns {}
impl Timer3Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer3_ns::RegisterBlock = 0x5005_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer3_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer3Ns {
    type Target = timer3_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer3Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer3Ns").finish()
    }
}
#[doc = "TIMER3_NS Registers"]
pub mod timer3_ns;
#[doc = "TIMER3_S Registers"]
pub struct Timer3S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer3S {}
impl Timer3S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer3_s::RegisterBlock = 0x4005_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer3_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer3S {
    type Target = timer3_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer3S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer3S").finish()
    }
}
#[doc = "TIMER3_S Registers"]
pub mod timer3_s;
#[doc = "TIMER4_NS Registers"]
pub struct Timer4Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer4Ns {}
impl Timer4Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer4_ns::RegisterBlock = 0x5005_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer4_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer4Ns {
    type Target = timer4_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer4Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer4Ns").finish()
    }
}
#[doc = "TIMER4_NS Registers"]
pub mod timer4_ns;
#[doc = "TIMER4_S Registers"]
pub struct Timer4S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer4S {}
impl Timer4S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer4_s::RegisterBlock = 0x4005_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer4_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer4S {
    type Target = timer4_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer4S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer4S").finish()
    }
}
#[doc = "TIMER4_S Registers"]
pub mod timer4_s;
#[doc = "ULFRCO_NS Registers"]
pub struct UlfrcoNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UlfrcoNs {}
impl UlfrcoNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ulfrco_ns::RegisterBlock = 0x5002_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ulfrco_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UlfrcoNs {
    type Target = ulfrco_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UlfrcoNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UlfrcoNs").finish()
    }
}
#[doc = "ULFRCO_NS Registers"]
pub mod ulfrco_ns;
#[doc = "ULFRCO_S Registers"]
pub struct UlfrcoS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UlfrcoS {}
impl UlfrcoS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ulfrco_s::RegisterBlock = 0x4002_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ulfrco_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UlfrcoS {
    type Target = ulfrco_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UlfrcoS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UlfrcoS").finish()
    }
}
#[doc = "ULFRCO_S Registers"]
pub mod ulfrco_s;
#[doc = "USART0_NS Registers"]
pub struct Usart0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usart0Ns {}
impl Usart0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usart0_ns::RegisterBlock = 0x5005_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usart0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usart0Ns {
    type Target = usart0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usart0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usart0Ns").finish()
    }
}
#[doc = "USART0_NS Registers"]
pub mod usart0_ns;
#[doc = "USART0_S Registers"]
pub struct Usart0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usart0S {}
impl Usart0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usart0_s::RegisterBlock = 0x4005_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usart0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usart0S {
    type Target = usart0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usart0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usart0S").finish()
    }
}
#[doc = "USART0_S Registers"]
pub mod usart0_s;
#[doc = "VDAC0_NS Registers"]
pub struct Vdac0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vdac0Ns {}
impl Vdac0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vdac0_ns::RegisterBlock = 0x5902_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vdac0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vdac0Ns {
    type Target = vdac0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vdac0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vdac0Ns").finish()
    }
}
#[doc = "VDAC0_NS Registers"]
pub mod vdac0_ns;
#[doc = "VDAC0_S Registers"]
pub struct Vdac0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vdac0S {}
impl Vdac0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vdac0_s::RegisterBlock = 0x4902_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vdac0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vdac0S {
    type Target = vdac0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vdac0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vdac0S").finish()
    }
}
#[doc = "VDAC0_S Registers"]
pub mod vdac0_s;
#[doc = "VDAC1_NS Registers"]
pub struct Vdac1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vdac1Ns {}
impl Vdac1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vdac1_ns::RegisterBlock = 0x5902_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vdac1_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vdac1Ns {
    type Target = vdac1_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vdac1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vdac1Ns").finish()
    }
}
#[doc = "VDAC1_NS Registers"]
pub mod vdac1_ns;
#[doc = "VDAC1_S Registers"]
pub struct Vdac1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vdac1S {}
impl Vdac1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vdac1_s::RegisterBlock = 0x4902_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vdac1_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vdac1S {
    type Target = vdac1_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vdac1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vdac1S").finish()
    }
}
#[doc = "VDAC1_S Registers"]
pub mod vdac1_s;
#[doc = "WDOG0_NS Registers"]
pub struct Wdog0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdog0Ns {}
impl Wdog0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdog0_ns::RegisterBlock = 0x5b00_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdog0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdog0Ns {
    type Target = wdog0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdog0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdog0Ns").finish()
    }
}
#[doc = "WDOG0_NS Registers"]
pub mod wdog0_ns;
#[doc = "WDOG0_S Registers"]
pub struct Wdog0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdog0S {}
impl Wdog0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdog0_s::RegisterBlock = 0x4b00_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdog0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdog0S {
    type Target = wdog0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdog0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdog0S").finish()
    }
}
#[doc = "WDOG0_S Registers"]
pub mod wdog0_s;
#[doc = "WDOG1_NS Registers"]
pub struct Wdog1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdog1Ns {}
impl Wdog1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdog1_ns::RegisterBlock = 0x5b00_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdog1_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdog1Ns {
    type Target = wdog1_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdog1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdog1Ns").finish()
    }
}
#[doc = "WDOG1_NS Registers"]
pub mod wdog1_ns;
#[doc = "WDOG1_S Registers"]
pub struct Wdog1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdog1S {}
impl Wdog1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdog1_s::RegisterBlock = 0x4b00_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdog1_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdog1S {
    type Target = wdog1_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdog1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdog1S").finish()
    }
}
#[doc = "WDOG1_S Registers"]
pub mod wdog1_s;
#[doc = "DEVINFO Registers"]
pub struct Devinfo {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Devinfo {}
impl Devinfo {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const devinfo::RegisterBlock = 0x0fe0_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const devinfo::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Devinfo {
    type Target = devinfo::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Devinfo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Devinfo").finish()
    }
}
#[doc = "DEVINFO Registers"]
pub mod devinfo;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "ACMP0_NS"]
    pub acmp0_ns: Acmp0Ns,
    #[doc = "ACMP0_S"]
    pub acmp0_s: Acmp0S,
    #[doc = "ACMP1_NS"]
    pub acmp1_ns: Acmp1Ns,
    #[doc = "ACMP1_S"]
    pub acmp1_s: Acmp1S,
    #[doc = "BURAM_NS"]
    pub buram_ns: BuramNs,
    #[doc = "BURAM_S"]
    pub buram_s: BuramS,
    #[doc = "BURTC_NS"]
    pub burtc_ns: BurtcNs,
    #[doc = "BURTC_S"]
    pub burtc_s: BurtcS,
    #[doc = "CMU_NS"]
    pub cmu_ns: CmuNs,
    #[doc = "CMU_S"]
    pub cmu_s: CmuS,
    #[doc = "DCDC_NS"]
    pub dcdc_ns: DcdcNs,
    #[doc = "DCDC_S"]
    pub dcdc_s: DcdcS,
    #[doc = "DMEM_NS"]
    pub dmem_ns: DmemNs,
    #[doc = "DMEM_S"]
    pub dmem_s: DmemS,
    #[doc = "DPLL0_NS"]
    pub dpll0_ns: Dpll0Ns,
    #[doc = "DPLL0_S"]
    pub dpll0_s: Dpll0S,
    #[doc = "EMU_NS"]
    pub emu_ns: EmuNs,
    #[doc = "EMU_S"]
    pub emu_s: EmuS,
    #[doc = "EUSART0_NS"]
    pub eusart0_ns: Eusart0Ns,
    #[doc = "EUSART0_S"]
    pub eusart0_s: Eusart0S,
    #[doc = "EUSART1_NS"]
    pub eusart1_ns: Eusart1Ns,
    #[doc = "EUSART1_S"]
    pub eusart1_s: Eusart1S,
    #[doc = "FSRCO_NS"]
    pub fsrco_ns: FsrcoNs,
    #[doc = "FSRCO_S"]
    pub fsrco_s: FsrcoS,
    #[doc = "GPCRC_NS"]
    pub gpcrc_ns: GpcrcNs,
    #[doc = "GPCRC_S"]
    pub gpcrc_s: GpcrcS,
    #[doc = "GPIO_NS"]
    pub gpio_ns: GpioNs,
    #[doc = "GPIO_S"]
    pub gpio_s: GpioS,
    #[doc = "HFRCO0_NS"]
    pub hfrco0_ns: Hfrco0Ns,
    #[doc = "HFRCO0_S"]
    pub hfrco0_s: Hfrco0S,
    #[doc = "HFRCOEM23_NS"]
    pub hfrcoem23_ns: Hfrcoem23Ns,
    #[doc = "HFRCOEM23_S"]
    pub hfrcoem23_s: Hfrcoem23S,
    #[doc = "HFXO0_NS"]
    pub hfxo0_ns: Hfxo0Ns,
    #[doc = "HFXO0_S"]
    pub hfxo0_s: Hfxo0S,
    #[doc = "HOSTMAILBOX_NS"]
    pub hostmailbox_ns: HostmailboxNs,
    #[doc = "HOSTMAILBOX_S"]
    pub hostmailbox_s: HostmailboxS,
    #[doc = "I2C0_NS"]
    pub i2c0_ns: I2c0Ns,
    #[doc = "I2C0_S"]
    pub i2c0_s: I2c0S,
    #[doc = "I2C1_NS"]
    pub i2c1_ns: I2c1Ns,
    #[doc = "I2C1_S"]
    pub i2c1_s: I2c1S,
    #[doc = "IADC0_NS"]
    pub iadc0_ns: Iadc0Ns,
    #[doc = "IADC0_S"]
    pub iadc0_s: Iadc0S,
    #[doc = "ICACHE0_NS"]
    pub icache0_ns: Icache0Ns,
    #[doc = "ICACHE0_S"]
    pub icache0_s: Icache0S,
    #[doc = "KEYSCAN_NS"]
    pub keyscan_ns: KeyscanNs,
    #[doc = "KEYSCAN_S"]
    pub keyscan_s: KeyscanS,
    #[doc = "LDMAXBAR_NS"]
    pub ldmaxbar_ns: LdmaxbarNs,
    #[doc = "LDMAXBAR_S"]
    pub ldmaxbar_s: LdmaxbarS,
    #[doc = "LDMA_NS"]
    pub ldma_ns: LdmaNs,
    #[doc = "LDMA_S"]
    pub ldma_s: LdmaS,
    #[doc = "LETIMER0_NS"]
    pub letimer0_ns: Letimer0Ns,
    #[doc = "LETIMER0_S"]
    pub letimer0_s: Letimer0S,
    #[doc = "LFRCO_NS"]
    pub lfrco_ns: LfrcoNs,
    #[doc = "LFRCO_S"]
    pub lfrco_s: LfrcoS,
    #[doc = "LFXO_NS"]
    pub lfxo_ns: LfxoNs,
    #[doc = "LFXO_S"]
    pub lfxo_s: LfxoS,
    #[doc = "MSC_NS"]
    pub msc_ns: MscNs,
    #[doc = "MSC_S"]
    pub msc_s: MscS,
    #[doc = "MVP_NS"]
    pub mvp_ns: MvpNs,
    #[doc = "MVP_S"]
    pub mvp_s: MvpS,
    #[doc = "PCNT0_NS"]
    pub pcnt0_ns: Pcnt0Ns,
    #[doc = "PCNT0_S"]
    pub pcnt0_s: Pcnt0S,
    #[doc = "PRS_NS"]
    pub prs_ns: PrsNs,
    #[doc = "PRS_S"]
    pub prs_s: PrsS,
    #[doc = "RADIOAES_NS"]
    pub radioaes_ns: RadioaesNs,
    #[doc = "RADIOAES_S"]
    pub radioaes_s: RadioaesS,
    #[doc = "SCRATCHPAD_NS"]
    pub scratchpad_ns: ScratchpadNs,
    #[doc = "SCRATCHPAD_S"]
    pub scratchpad_s: ScratchpadS,
    #[doc = "SEMAILBOX_NS_HOST"]
    pub semailbox_ns_host: SemailboxNsHost,
    #[doc = "SEMAILBOX_S_HOST"]
    pub semailbox_s_host: SemailboxSHost,
    #[doc = "SMU_NS"]
    pub smu_ns: SmuNs,
    #[doc = "SMU_NS_CFGNS"]
    pub smu_ns_cfgns: SmuNsCfgns,
    #[doc = "SMU_S"]
    pub smu_s: SmuS,
    #[doc = "SMU_S_CFGNS"]
    pub smu_s_cfgns: SmuSCfgns,
    #[doc = "SYSCFG_NS"]
    pub syscfg_ns: SyscfgNs,
    #[doc = "SYSCFG_NS_CFGNS"]
    pub syscfg_ns_cfgns: SyscfgNsCfgns,
    #[doc = "SYSCFG_S"]
    pub syscfg_s: SyscfgS,
    #[doc = "SYSCFG_S_CFGNS"]
    pub syscfg_s_cfgns: SyscfgSCfgns,
    #[doc = "SYSRTC0_NS"]
    pub sysrtc0_ns: Sysrtc0Ns,
    #[doc = "SYSRTC0_S"]
    pub sysrtc0_s: Sysrtc0S,
    #[doc = "TIMER0_NS"]
    pub timer0_ns: Timer0Ns,
    #[doc = "TIMER0_S"]
    pub timer0_s: Timer0S,
    #[doc = "TIMER1_NS"]
    pub timer1_ns: Timer1Ns,
    #[doc = "TIMER1_S"]
    pub timer1_s: Timer1S,
    #[doc = "TIMER2_NS"]
    pub timer2_ns: Timer2Ns,
    #[doc = "TIMER2_S"]
    pub timer2_s: Timer2S,
    #[doc = "TIMER3_NS"]
    pub timer3_ns: Timer3Ns,
    #[doc = "TIMER3_S"]
    pub timer3_s: Timer3S,
    #[doc = "TIMER4_NS"]
    pub timer4_ns: Timer4Ns,
    #[doc = "TIMER4_S"]
    pub timer4_s: Timer4S,
    #[doc = "ULFRCO_NS"]
    pub ulfrco_ns: UlfrcoNs,
    #[doc = "ULFRCO_S"]
    pub ulfrco_s: UlfrcoS,
    #[doc = "USART0_NS"]
    pub usart0_ns: Usart0Ns,
    #[doc = "USART0_S"]
    pub usart0_s: Usart0S,
    #[doc = "VDAC0_NS"]
    pub vdac0_ns: Vdac0Ns,
    #[doc = "VDAC0_S"]
    pub vdac0_s: Vdac0S,
    #[doc = "VDAC1_NS"]
    pub vdac1_ns: Vdac1Ns,
    #[doc = "VDAC1_S"]
    pub vdac1_s: Vdac1S,
    #[doc = "WDOG0_NS"]
    pub wdog0_ns: Wdog0Ns,
    #[doc = "WDOG0_S"]
    pub wdog0_s: Wdog0S,
    #[doc = "WDOG1_NS"]
    pub wdog1_ns: Wdog1Ns,
    #[doc = "WDOG1_S"]
    pub wdog1_s: Wdog1S,
    #[doc = "DEVINFO"]
    pub devinfo: Devinfo,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            acmp0_ns: Acmp0Ns::steal(),
            acmp0_s: Acmp0S::steal(),
            acmp1_ns: Acmp1Ns::steal(),
            acmp1_s: Acmp1S::steal(),
            buram_ns: BuramNs::steal(),
            buram_s: BuramS::steal(),
            burtc_ns: BurtcNs::steal(),
            burtc_s: BurtcS::steal(),
            cmu_ns: CmuNs::steal(),
            cmu_s: CmuS::steal(),
            dcdc_ns: DcdcNs::steal(),
            dcdc_s: DcdcS::steal(),
            dmem_ns: DmemNs::steal(),
            dmem_s: DmemS::steal(),
            dpll0_ns: Dpll0Ns::steal(),
            dpll0_s: Dpll0S::steal(),
            emu_ns: EmuNs::steal(),
            emu_s: EmuS::steal(),
            eusart0_ns: Eusart0Ns::steal(),
            eusart0_s: Eusart0S::steal(),
            eusart1_ns: Eusart1Ns::steal(),
            eusart1_s: Eusart1S::steal(),
            fsrco_ns: FsrcoNs::steal(),
            fsrco_s: FsrcoS::steal(),
            gpcrc_ns: GpcrcNs::steal(),
            gpcrc_s: GpcrcS::steal(),
            gpio_ns: GpioNs::steal(),
            gpio_s: GpioS::steal(),
            hfrco0_ns: Hfrco0Ns::steal(),
            hfrco0_s: Hfrco0S::steal(),
            hfrcoem23_ns: Hfrcoem23Ns::steal(),
            hfrcoem23_s: Hfrcoem23S::steal(),
            hfxo0_ns: Hfxo0Ns::steal(),
            hfxo0_s: Hfxo0S::steal(),
            hostmailbox_ns: HostmailboxNs::steal(),
            hostmailbox_s: HostmailboxS::steal(),
            i2c0_ns: I2c0Ns::steal(),
            i2c0_s: I2c0S::steal(),
            i2c1_ns: I2c1Ns::steal(),
            i2c1_s: I2c1S::steal(),
            iadc0_ns: Iadc0Ns::steal(),
            iadc0_s: Iadc0S::steal(),
            icache0_ns: Icache0Ns::steal(),
            icache0_s: Icache0S::steal(),
            keyscan_ns: KeyscanNs::steal(),
            keyscan_s: KeyscanS::steal(),
            ldmaxbar_ns: LdmaxbarNs::steal(),
            ldmaxbar_s: LdmaxbarS::steal(),
            ldma_ns: LdmaNs::steal(),
            ldma_s: LdmaS::steal(),
            letimer0_ns: Letimer0Ns::steal(),
            letimer0_s: Letimer0S::steal(),
            lfrco_ns: LfrcoNs::steal(),
            lfrco_s: LfrcoS::steal(),
            lfxo_ns: LfxoNs::steal(),
            lfxo_s: LfxoS::steal(),
            msc_ns: MscNs::steal(),
            msc_s: MscS::steal(),
            mvp_ns: MvpNs::steal(),
            mvp_s: MvpS::steal(),
            pcnt0_ns: Pcnt0Ns::steal(),
            pcnt0_s: Pcnt0S::steal(),
            prs_ns: PrsNs::steal(),
            prs_s: PrsS::steal(),
            radioaes_ns: RadioaesNs::steal(),
            radioaes_s: RadioaesS::steal(),
            scratchpad_ns: ScratchpadNs::steal(),
            scratchpad_s: ScratchpadS::steal(),
            semailbox_ns_host: SemailboxNsHost::steal(),
            semailbox_s_host: SemailboxSHost::steal(),
            smu_ns: SmuNs::steal(),
            smu_ns_cfgns: SmuNsCfgns::steal(),
            smu_s: SmuS::steal(),
            smu_s_cfgns: SmuSCfgns::steal(),
            syscfg_ns: SyscfgNs::steal(),
            syscfg_ns_cfgns: SyscfgNsCfgns::steal(),
            syscfg_s: SyscfgS::steal(),
            syscfg_s_cfgns: SyscfgSCfgns::steal(),
            sysrtc0_ns: Sysrtc0Ns::steal(),
            sysrtc0_s: Sysrtc0S::steal(),
            timer0_ns: Timer0Ns::steal(),
            timer0_s: Timer0S::steal(),
            timer1_ns: Timer1Ns::steal(),
            timer1_s: Timer1S::steal(),
            timer2_ns: Timer2Ns::steal(),
            timer2_s: Timer2S::steal(),
            timer3_ns: Timer3Ns::steal(),
            timer3_s: Timer3S::steal(),
            timer4_ns: Timer4Ns::steal(),
            timer4_s: Timer4S::steal(),
            ulfrco_ns: UlfrcoNs::steal(),
            ulfrco_s: UlfrcoS::steal(),
            usart0_ns: Usart0Ns::steal(),
            usart0_s: Usart0S::steal(),
            vdac0_ns: Vdac0Ns::steal(),
            vdac0_s: Vdac0S::steal(),
            vdac1_ns: Vdac1Ns::steal(),
            vdac1_s: Vdac1S::steal(),
            wdog0_ns: Wdog0Ns::steal(),
            wdog0_s: Wdog0S::steal(),
            wdog1_ns: Wdog1Ns::steal(),
            wdog1_s: Wdog1S::steal(),
            devinfo: Devinfo::steal(),
        }
    }
}
